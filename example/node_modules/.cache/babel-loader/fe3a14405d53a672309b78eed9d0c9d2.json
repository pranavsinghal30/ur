{"ast":null,"code":"var _classCallCheck = require(\"/home/pranavagarwal/Downloads/dashboard-react/tabler-react/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pranavagarwal/Downloads/dashboard-react/tabler-react/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/pranavagarwal/Downloads/dashboard-react/tabler-react/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/pranavagarwal/Downloads/dashboard-react/tabler-react/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/pranavagarwal/Downloads/dashboard-react/tabler-react/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _slicedToArray = require(\"/home/pranavagarwal/Downloads/dashboard-react/tabler-react/example/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar bufferFrom = require('buffer-from');\n\nvar bufferAlloc = require('buffer-alloc');\n\nvar _bufferFrom = bufferFrom('\\r'),\n    _bufferFrom2 = _slicedToArray(_bufferFrom, 1),\n    cr = _bufferFrom2[0];\n\nvar _bufferFrom3 = bufferFrom('\\n'),\n    _bufferFrom4 = _slicedToArray(_bufferFrom3, 1),\n    nl = _bufferFrom4[0];\n\nvar defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: function mapHeaders(_ref) {\n    var header = _ref.header;\n    return header;\n  },\n  mapValues: function mapValues(_ref2) {\n    var value = _ref2.value;\n    return value;\n  },\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false\n};\n\nvar CsvParser =\n/*#__PURE__*/\nfunction (_Transform) {\n  \"use strict\";\n\n  _inherits(CsvParser, _Transform);\n\n  function CsvParser() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, CsvParser);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CsvParser).call(this, {\n      objectMode: true,\n      highWaterMark: 16\n    }));\n    if (Array.isArray(opts)) opts = {\n      headers: opts\n    };\n    var options = Object.assign({}, defaults, opts);\n    options.customNewline = options.newline !== defaults.newline;\n    var _arr = ['newline', 'quote', 'separator'];\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var key = _arr[_i];\n\n      if (typeof options[key] !== 'undefined') {\n        var _bufferFrom5 = bufferFrom(options[key]);\n\n        var _bufferFrom6 = _slicedToArray(_bufferFrom5, 1);\n\n        options[key] = _bufferFrom6[0];\n      }\n    } // if escape is not defined on the passed options, use the end value of quote\n\n\n    options.escape = (opts || {}).escape ? bufferFrom(options.escape)[0] : options.quote;\n    _this.state = {\n      empty: options.raw ? bufferAlloc(0) : '',\n      escaped: false,\n      first: true,\n      lineNumber: 0,\n      previousEnd: 0,\n      rowLength: 0,\n      quoted: false\n    };\n    _this._prev = null;\n\n    if (options.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      options.strict = false;\n    }\n\n    if (options.headers || options.headers === false) {\n      _this.state.first = false;\n    }\n\n    _this.options = options;\n    _this.headers = options.headers;\n    return _this;\n  }\n\n  _createClass(CsvParser, [{\n    key: \"parseCell\",\n    value: function parseCell(buffer, start, end) {\n      var _this$options = this.options,\n          escape = _this$options.escape,\n          quote = _this$options.quote; // remove quotes from quoted cells\n\n      if (buffer[start] === quote && buffer[end - 1] === quote) {\n        start++;\n        end--;\n      }\n\n      var y = start;\n\n      for (var i = start; i < end; i++) {\n        // check for escape characters and skip them\n        if (buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote) {\n          i++;\n        }\n\n        if (y !== i) {\n          buffer[y] = buffer[i];\n        }\n\n        y++;\n      }\n\n      return this.parseValue(buffer, start, y);\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(buffer, start, end) {\n      var _this2 = this;\n\n      var _this$options2 = this.options,\n          customNewline = _this$options2.customNewline,\n          escape = _this$options2.escape,\n          mapHeaders = _this$options2.mapHeaders,\n          mapValues = _this$options2.mapValues,\n          quote = _this$options2.quote,\n          separator = _this$options2.separator,\n          skipComments = _this$options2.skipComments,\n          skipLines = _this$options2.skipLines;\n      end--; // trim newline\n\n      if (!customNewline && buffer.length && buffer[end - 1] === cr) {\n        end--;\n      }\n\n      var comma = separator;\n      var cells = [];\n      var isQuoted = false;\n      var offset = start;\n\n      if (skipComments) {\n        var char = typeof skipComments === 'string' ? skipComments : '#';\n\n        if (buffer[start] === bufferFrom(char)[0]) {\n          return;\n        }\n      }\n\n      var mapValue = function mapValue(value) {\n        if (_this2.state.first) {\n          return value;\n        }\n\n        var index = cells.length;\n        var header = _this2.headers[index];\n        return mapValues({\n          header: header,\n          index: index,\n          value: value\n        });\n      };\n\n      for (var i = start; i < end; i++) {\n        var isStartingQuote = !isQuoted && buffer[i] === quote;\n        var isEndingQuote = isQuoted && buffer[i] === quote && i + 1 <= end && buffer[i + 1] === comma;\n        var isEscape = isQuoted && buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote;\n\n        if (isStartingQuote || isEndingQuote) {\n          isQuoted = !isQuoted;\n          continue;\n        } else if (isEscape) {\n          i++;\n          continue;\n        }\n\n        if (buffer[i] === comma && !isQuoted) {\n          var value = this.parseCell(buffer, offset, i);\n          value = mapValue(value);\n          cells.push(value);\n          offset = i + 1;\n        }\n      }\n\n      if (offset < end) {\n        var _value = this.parseCell(buffer, offset, end);\n\n        _value = mapValue(_value);\n        cells.push(_value);\n      }\n\n      if (buffer[end - 1] === comma) {\n        cells.push(mapValue(this.state.empty));\n      }\n\n      var skip = skipLines && skipLines > this.state.lineNumber;\n      this.state.lineNumber++;\n\n      if (this.state.first && !skip) {\n        this.state.first = false;\n        this.headers = cells.map(function (header, index) {\n          return mapHeaders({\n            header: header,\n            index: index\n          });\n        });\n        this.emit('headers', this.headers);\n        return;\n      }\n\n      if (!skip && this.options.strict && cells.length !== this.headers.length) {\n        var e = new RangeError('Row length does not match headers');\n        this.emit('error', e);\n      } else {\n        if (!skip) this.writeRow(cells);\n      }\n    }\n  }, {\n    key: \"parseValue\",\n    value: function parseValue(buffer, start, end) {\n      if (this.options.raw) {\n        return buffer.slice(start, end);\n      }\n\n      return buffer.toString('utf-8', start, end);\n    }\n  }, {\n    key: \"writeRow\",\n    value: function writeRow(cells) {\n      var _this3 = this;\n\n      if (this.headers === false || cells.length > this.headers.length) {\n        this.headers = cells.map(function (value, index) {\n          return index;\n        });\n      }\n\n      var row = cells.reduce(function (o, cell, index) {\n        var header = _this3.headers[index];\n\n        if (header !== null) {\n          o[header] = cell;\n        }\n\n        return o;\n      }, {});\n      this.push(row);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(cb) {\n      if (this.state.escaped || !this._prev) return cb();\n      this.parseLine(this._prev, this.state.previousEnd, this._prev.length + 1); // plus since online -1s\n\n      cb();\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(data, enc, cb) {\n      if (typeof data === 'string') {\n        data = bufferFrom(data);\n      }\n\n      var _this$options3 = this.options,\n          escape = _this$options3.escape,\n          quote = _this$options3.quote;\n      var start = 0;\n      var buffer = data;\n\n      if (this._prev) {\n        start = this._prev.length;\n        buffer = Buffer.concat([this._prev, data]);\n        this._prev = null;\n      }\n\n      var bufferLength = buffer.length;\n\n      for (var i = start; i < bufferLength; i++) {\n        var chr = buffer[i];\n        var nextChr = i + 1 < bufferLength ? buffer[i + 1] : null;\n        this.state.rowLength++;\n\n        if (this.state.rowLength > this.options.maxRowBytes) {\n          return cb(new Error('Row exceeds the maximum size'));\n        }\n\n        if (!this.state.escaped && chr === escape && nextChr === quote && i !== start) {\n          this.state.escaped = true;\n          continue;\n        } else if (chr === quote) {\n          if (this.state.escaped) {\n            this.state.escaped = false; // non-escaped quote (quoting the cell)\n          } else {\n            this.state.quoted = !this.state.quoted;\n          }\n\n          continue;\n        }\n\n        if (!this.state.quoted) {\n          if (this.state.first && !this.options.customNewline) {\n            if (chr === nl) {\n              this.options.newline = nl;\n            } else if (chr === cr) {\n              if (nextChr !== nl) {\n                this.options.newline = cr;\n              }\n            }\n          }\n\n          if (chr === this.options.newline) {\n            this.parseLine(buffer, this.state.previousEnd, i + 1);\n            this.state.previousEnd = i + 1;\n            this.state.rowLength = 0;\n          }\n        }\n      }\n\n      if (this.state.previousEnd === bufferLength) {\n        this.state.previousEnd = 0;\n        return cb();\n      }\n\n      if (bufferLength - this.state.previousEnd < data.length) {\n        this._prev = data;\n        this.state.previousEnd -= bufferLength - data.length;\n        return cb();\n      }\n\n      this._prev = buffer;\n      cb();\n    }\n  }]);\n\n  return CsvParser;\n}(Transform);\n\nmodule.exports = function (opts) {\n  return new CsvParser(opts);\n};","map":null,"metadata":{},"sourceType":"script"}